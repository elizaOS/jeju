/**
 * OIF (Open Intents Framework) Event Processor
 * 
 * Indexes cross-chain intent events from InputSettler, OutputSettler, and SolverRegistry
 */

import { Store } from '@subsquid/typeorm-store'
import { ProcessorContext } from './processor'
import { ethers } from 'ethers'

// Note: Import these from model once generated with sqd codegen
// For now, we define interfaces for the events

// Event signatures for InputSettler
const ORDER_OPENED = ethers.id('Open(bytes32,(address,uint256,uint32,uint32,bytes32,(bytes32,uint256,bytes32,uint256)[],(bytes32,uint256,bytes32,uint256)[],(uint64,bytes32,bytes)[]))')
const ORDER_CREATED = ethers.id('OrderCreated(bytes32,address,address,uint256,uint256,address,uint32)')
const ORDER_CLAIMED = ethers.id('OrderClaimed(bytes32,address,uint256)')
const ORDER_SETTLED = ethers.id('OrderSettled(bytes32,address,uint256,uint256)')
const ORDER_REFUNDED = ethers.id('OrderRefunded(bytes32,address,uint256)')

// Event signatures for OutputSettler
const FILL_EVENT = ethers.id('Fill(bytes32,bytes32,bytes)')
const ORDER_FILLED = ethers.id('OrderFilled(bytes32,address,address,address,uint256)')
const LIQUIDITY_DEPOSITED = ethers.id('LiquidityDeposited(address,address,uint256)')
const LIQUIDITY_WITHDRAWN = ethers.id('LiquidityWithdrawn(address,address,uint256)')

// Event signatures for SolverRegistry
const SOLVER_REGISTERED = ethers.id('SolverRegistered(address,uint256,uint256[])')
const SOLVER_STAKE_DEPOSITED = ethers.id('SolverStakeDeposited(address,uint256,uint256)')
const SOLVER_SLASHED = ethers.id('SolverSlashed(address,bytes32,uint256)')
const SOLVER_WITHDRAWN = ethers.id('SolverWithdrawn(address,uint256)')
const FILL_RECORDED = ethers.id('FillRecorded(address,bytes32,bool)')

// Event signatures for Oracle
const ATTESTATION_SUBMITTED = ethers.id('AttestationSubmitted(bytes32,address,uint256)')

const OIF_EVENT_SIGNATURES = new Set([
    ORDER_OPENED, ORDER_CREATED, ORDER_CLAIMED, ORDER_SETTLED, ORDER_REFUNDED,
    FILL_EVENT, ORDER_FILLED, LIQUIDITY_DEPOSITED, LIQUIDITY_WITHDRAWN,
    SOLVER_REGISTERED, SOLVER_STAKE_DEPOSITED, SOLVER_SLASHED, SOLVER_WITHDRAWN, FILL_RECORDED,
    ATTESTATION_SUBMITTED
])

interface LogData {
    address: string
    topics: string[]
    data: string
    logIndex: number
    transactionIndex: number
    transaction?: { hash: string }
}

interface BlockHeader {
    hash: string
    height: number
    timestamp: number
}

// OIF Entity interfaces (will be generated by sqd codegen from schema)
interface OIFIntentData {
    id: string
    intentId: string
    user: string
    sourceChainId: number
    inputToken: string
    inputAmount: bigint
    outputToken: string
    outputAmount: bigint
    outputChainId: number
    recipient: string
    maxFee: bigint
    status: string
    createdAt: Date
    createdBlock: bigint
    inputSettlerTx: string
}

interface OIFSolverData {
    id: string
    address: string
    stakedAmount: bigint
    isActive: boolean
    registeredAt: Date
    supportedChains: number[]
    totalFills: number
    successfulFills: number
    reputation: number
}

interface OIFSettlementData {
    id: string
    intentId: string
    solver: string
    status: string
    createdAt: Date
}

// Storage maps for batch operations
const pendingIntents = new Map<string, OIFIntentData>()
const pendingSolvers = new Map<string, OIFSolverData>()
const pendingSettlements = new Map<string, OIFSettlementData>()

export function isOIFEvent(topic0: string): boolean {
    return OIF_EVENT_SIGNATURES.has(topic0)
}

export async function processOIFEvents(ctx: ProcessorContext<Store>): Promise<void> {
    const intents = new Map<string, OIFIntentData>()
    const solvers = new Map<string, OIFSolverData>()
    const settlements = new Map<string, OIFSettlementData>()

    for (const block of ctx.blocks) {
        const header = block.header as unknown as BlockHeader
        const blockTimestamp = new Date(header.timestamp)

        for (const rawLog of block.logs) {
            const log = rawLog as unknown as LogData
            const eventSig = log.topics[0]

            if (!eventSig || !OIF_EVENT_SIGNATURES.has(eventSig)) continue

            const txHash = log.transaction?.hash || `${header.hash}-${log.transactionIndex}`

            // Process each event type
            if (eventSig === ORDER_CREATED) {
                const orderId = log.topics[1]
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                    ['address', 'address', 'uint256', 'uint256', 'address', 'uint32'],
                    log.data
                )

                const intent: OIFIntentData = {
                    id: orderId,
                    intentId: orderId,
                    user: decoded[0],
                    sourceChainId: 8453, // Would come from contract address mapping
                    inputToken: decoded[1],
                    inputAmount: BigInt(decoded[2].toString()),
                    outputToken: decoded[1], // Same for now
                    outputAmount: BigInt(decoded[2].toString()) * 995n / 1000n,
                    outputChainId: Number(decoded[3]),
                    recipient: decoded[4],
                    maxFee: 0n,
                    status: 'OPEN',
                    createdAt: blockTimestamp,
                    createdBlock: BigInt(header.height),
                    inputSettlerTx: txHash
                }

                intents.set(orderId, intent)
                ctx.log.info(`OIF Intent created: ${orderId.slice(0, 16)}...`)
            }

            if (eventSig === ORDER_CLAIMED) {
                const orderId = log.topics[1]
                const intent = intents.get(orderId)
                if (intent) {
                    intent.status = 'CLAIMED'
                }
            }

            if (eventSig === ORDER_FILLED) {
                const orderId = log.topics[1]
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                    ['address', 'address', 'address', 'uint256'],
                    log.data
                )
                
                const intent = intents.get(orderId)
                if (intent) {
                    intent.status = 'FILLED'
                }

                const settlement: OIFSettlementData = {
                    id: `${orderId}-${txHash}`,
                    intentId: orderId,
                    solver: decoded[0],
                    status: 'PENDING',
                    createdAt: blockTimestamp
                }
                settlements.set(settlement.id, settlement)
            }

            if (eventSig === ORDER_SETTLED) {
                const orderId = log.topics[1]
                const intent = intents.get(orderId)
                if (intent) {
                    intent.status = 'SETTLED'
                }
                
                // Update settlement status
                for (const [id, settlement] of settlements) {
                    if (settlement.intentId === orderId) {
                        settlement.status = 'SETTLED'
                    }
                }
            }

            if (eventSig === ORDER_REFUNDED) {
                const orderId = log.topics[1]
                const intent = intents.get(orderId)
                if (intent) {
                    intent.status = 'REFUNDED'
                }
            }

            if (eventSig === SOLVER_REGISTERED) {
                const solverAddr = log.topics[1]
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                    ['uint256', 'uint256[]'],
                    log.data
                )

                const solver: OIFSolverData = {
                    id: solverAddr,
                    address: solverAddr,
                    stakedAmount: BigInt(decoded[0].toString()),
                    isActive: true,
                    registeredAt: blockTimestamp,
                    supportedChains: decoded[1].map((c: bigint) => Number(c)),
                    totalFills: 0,
                    successfulFills: 0,
                    reputation: 50 // Starting reputation
                }

                solvers.set(solverAddr, solver)
                ctx.log.info(`OIF Solver registered: ${solverAddr.slice(0, 16)}...`)
            }

            if (eventSig === SOLVER_STAKE_DEPOSITED) {
                const solverAddr = log.topics[1]
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                    ['uint256', 'uint256'],
                    log.data
                )

                const solver = solvers.get(solverAddr)
                if (solver) {
                    solver.stakedAmount = BigInt(decoded[1].toString())
                }
            }

            if (eventSig === SOLVER_SLASHED) {
                const solverAddr = log.topics[1]
                const solver = solvers.get(solverAddr)
                if (solver) {
                    // Decrease reputation on slash
                    solver.reputation = Math.max(0, solver.reputation - 10)
                }
            }

            if (eventSig === FILL_RECORDED) {
                const solverAddr = log.topics[1]
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                    ['bytes32', 'bool'],
                    log.data
                )
                
                const success = decoded[1]
                const solver = solvers.get(solverAddr)
                if (solver) {
                    solver.totalFills++
                    if (success) {
                        solver.successfulFills++
                        // Increase reputation on successful fill
                        solver.reputation = Math.min(100, solver.reputation + 1)
                    }
                }
            }

            if (eventSig === ATTESTATION_SUBMITTED) {
                const orderId = log.topics[1]
                // Update settlement to attested
                for (const [id, settlement] of settlements) {
                    if (settlement.intentId === orderId) {
                        settlement.status = 'ATTESTED'
                    }
                }
            }
        }
    }

    // Persist to database
    ctx.log.info(`OIF Processor: Saving ${intents.size} intents, ${solvers.size} solvers, ${settlements.size} settlements`)
    
    // Convert maps to arrays for batch save
    const intentEntities = Array.from(intents.values()).map(intent => ({
        ...intent,
        inputAmount: intent.inputAmount.toString(),
        outputAmount: intent.outputAmount.toString(),
        maxFee: intent.maxFee.toString(),
        createdBlock: Number(intent.createdBlock),
    }));

    const solverEntities = Array.from(solvers.values()).map(solver => ({
        ...solver,
        stakedAmount: solver.stakedAmount.toString(),
    }));

    const settlementEntities = Array.from(settlements.values());

    // Upsert entities using store
    // Note: These entity types must be defined in schema.graphql and generated
    // For now, we use a generic approach
    if (intentEntities.length > 0) {
        for (const intent of intentEntities) {
            await ctx.store.upsert({ id: intent.id, ...intent } as unknown as { id: string });
        }
        ctx.log.info(`Saved ${intentEntities.length} OIF intents`);
    }

    if (solverEntities.length > 0) {
        for (const solver of solverEntities) {
            await ctx.store.upsert({ id: solver.id, ...solver } as unknown as { id: string });
        }
        ctx.log.info(`Saved ${solverEntities.length} OIF solvers`);
    }

    if (settlementEntities.length > 0) {
        for (const settlement of settlementEntities) {
            await ctx.store.upsert({ id: settlement.id, ...settlement } as unknown as { id: string });
        }
        ctx.log.info(`Saved ${settlementEntities.length} OIF settlements`);
    }

    // Also update in-memory cache for stats
    for (const [id, intent] of intents) {
        pendingIntents.set(id, intent)
    }
    for (const [id, solver] of solvers) {
        pendingSolvers.set(id, solver)
    }
    for (const [id, settlement] of settlements) {
        pendingSettlements.set(id, settlement)
    }
}

// Export stats for monitoring
export function getOIFProcessorStats(): { intents: number; solvers: number; settlements: number } {
    return {
        intents: pendingIntents.size,
        solvers: pendingSolvers.size,
        settlements: pendingSettlements.size
    }
}

