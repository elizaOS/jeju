apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "rpc-gateway.fullname" . }}
  labels:
    {{- include "rpc-gateway.labels" . | nindent 4 }}
data:
  nginx.conf: |
    worker_processes auto;
    error_log /var/log/nginx/error.log {{ .Values.logging.level }};
    pid /tmp/nginx.pid;

    events {
      worker_connections 10000;
      use epoll;
      multi_accept on;
    }

    http {
      include /etc/nginx/mime.types;
      default_type application/json;

      # Logging
      {{- if .Values.logging.accessLog }}
      log_format json_combined escape=json
        '{'
          '"time":"$time_iso8601",'
          '"remote_addr":"$remote_addr",'
          '"request_method":"$request_method",'
          '"request_uri":"$request_uri",'
          '"status":$status,'
          '"body_bytes_sent":$body_bytes_sent,'
          '"request_time":$request_time,'
          '"upstream_response_time":"$upstream_response_time",'
          '"upstream_addr":"$upstream_addr",'
          '"http_user_agent":"$http_user_agent"'
        '}';
      
      access_log /var/log/nginx/access.log json_combined;
      {{- else }}
      access_log off;
      {{- end }}

      # Performance
      sendfile on;
      tcp_nopush on;
      tcp_nodelay on;
      keepalive_timeout 65;
      keepalive_requests 1000;

      # Buffers
      client_body_buffer_size 128k;
      client_max_body_size 1m;
      client_header_buffer_size 1k;
      large_client_header_buffers 4 8k;

      # Rate limiting zones
      {{- if .Values.rateLimit.enabled }}
      limit_req_zone $binary_remote_addr zone=rpc_rps:10m rate={{ .Values.rateLimit.requestsPerSecond }}r/s;
      limit_req_zone $binary_remote_addr zone=rpc_rpm:10m rate={{ div .Values.rateLimit.requestsPerMinute 60 }}r/s;
      limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
      {{- end }}

      # Upstream backend (multiple RPC nodes)
      upstream rpc_backend {
        least_conn;
        keepalive 100;
        keepalive_requests 1000;
        
        {{- $rpcService := .Values.backend.rpcService -}}
        {{- $rpcPort := .Values.backend.rpcPort -}}
        # This will be resolved by Kubernetes DNS to load balance across RPC pods
        server {{ $rpcService }}:{{ $rpcPort }} max_fails=3 fail_timeout=30s;
      }

      upstream ws_backend {
        least_conn;
        keepalive 100;
        
        {{- $rpcService := .Values.backend.rpcService -}}
        {{- $wsPort := .Values.backend.wsPort -}}
        server {{ $rpcService }}:{{ $wsPort }} max_fails=3 fail_timeout=30s;
      }

      # HTTP RPC Server
      server {
        listen 80;
        server_name _;

        # Rate limiting
        {{- if .Values.rateLimit.enabled }}
        limit_req zone=rpc_rps burst={{ .Values.rateLimit.burstSize }} nodelay;
        limit_req zone=rpc_rpm burst={{ mul .Values.rateLimit.burstSize 2 }};
        limit_conn conn_limit {{ .Values.rateLimit.maxConnectionsPerIp }};
        {{- end }}

        # Health check endpoint
        location /health {
          access_log off;
          return 200 '{"status":"ok"}';
          add_header Content-Type application/json;
        }

        # Metrics endpoint
        location /metrics {
          access_log off;
          stub_status on;
        }

        # RPC endpoint
        location / {
          # CORS headers
          add_header 'Access-Control-Allow-Origin' '*' always;
          add_header 'Access-Control-Allow-Methods' 'POST, OPTIONS' always;
          add_header 'Access-Control-Allow-Headers' 'Content-Type' always;
          
          if ($request_method = 'OPTIONS') {
            return 204;
          }

          # Only allow POST
          limit_except POST {
            deny all;
          }

          # Proxy settings
          proxy_pass http://rpc_backend;
          proxy_http_version 1.1;
          proxy_set_header Connection "";
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto $scheme;

          # Timeouts
          proxy_connect_timeout 10s;
          proxy_send_timeout 60s;
          proxy_read_timeout 60s;

          # Buffering
          proxy_buffering on;
          proxy_buffer_size 8k;
          proxy_buffers 4 8k;
          proxy_busy_buffers_size 16k;

          # Retry logic
          proxy_next_upstream error timeout http_502 http_503 http_504;
          proxy_next_upstream_tries 2;
        }
      }

      # WebSocket Server
      server {
        listen 8546;
        server_name _;

        {{- if .Values.rateLimit.enabled }}
        limit_conn conn_limit {{ .Values.rateLimit.maxConnectionsPerIp }};
        {{- end }}

        location / {
          proxy_pass http://ws_backend;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          
          # WebSocket timeouts
          proxy_connect_timeout 7d;
          proxy_send_timeout 7d;
          proxy_read_timeout 7d;
        }
      }
    }


