# Subsquid Schema for Jeju Network
# Core blockchain indexing entities

# ============ Core Blockchain Entities ============

type Block @entity {
  id: ID!
  number: Int! @index
  hash: String!
  parentHash: String!
  timestamp: DateTime! @index
  transactionCount: Int!
  gasUsed: BigInt!
  gasLimit: BigInt!
  baseFeePerGas: BigInt
  size: Int!
  miner: Account
  transactions: [Transaction!]! @derivedFrom(field: "block")
  logs: [Log!]! @derivedFrom(field: "block")
}

type Transaction @entity {
  id: ID!
  hash: String! @unique @index
  from: Account!
  to: Account
  block: Block!
  blockNumber: Int! @index
  transactionIndex: Int!
  value: BigInt!
  gasPrice: BigInt
  gasLimit: BigInt!
  gasUsed: BigInt
  input: String
  nonce: Int!
  status: TransactionStatus!
  type: Int
  maxFeePerGas: BigInt
  maxPriorityFeePerGas: BigInt
  contractAddress: Account
  logs: [Log!]! @derivedFrom(field: "transaction")
  traces: [Trace!]! @derivedFrom(field: "transaction")
}

enum TransactionStatus {
  SUCCESS
  FAILURE
  PENDING
}

type Account @entity {
  id: ID!
  address: String! @unique @index
  isContract: Boolean!
  firstSeenBlock: Int! @index
  lastSeenBlock: Int! @index
  transactionCount: Int!
  totalValueSent: BigInt!
  totalValueReceived: BigInt!
  labels: [String!]!
  contract: Contract
  firstSeenAt: DateTime! @index
  lastSeenAt: DateTime! @index
  sentTransactions: [Transaction!]! @derivedFrom(field: "from")
  receivedTransactions: [Transaction!]! @derivedFrom(field: "to")
  tokenBalances: [TokenBalance!]! @derivedFrom(field: "account")
  createdContracts: [Contract!]! @derivedFrom(field: "creator")
  tokenTransfersFrom: [TokenTransfer!]! @derivedFrom(field: "from")
  tokenTransfersTo: [TokenTransfer!]! @derivedFrom(field: "to")
}

type Contract @entity {
  id: ID!
  address: String! @unique @index
  bytecode: String
  contractType: ContractType
  isERC20: Boolean!
  isERC721: Boolean!
  isERC1155: Boolean!
  isProxy: Boolean!
  implementationAddress: String
  verified: Boolean!
  firstSeenAt: DateTime! @index
  lastSeenAt: DateTime! @index
  creator: Account
  creationTransaction: Transaction
  creationBlock: Block
  tokenTransfers: [TokenTransfer!]! @derivedFrom(field: "token")
}

enum ContractType {
  UNKNOWN
  ERC20
  ERC721
  ERC1155
  PROXY
  MULTISIG
  DEX
  LENDING
  NFT_MARKETPLACE
  GAME
  PREDICTION_MARKET
  GOVERNANCE
}

type Log @entity {
  id: ID!
  address: Account!
  data: String!
  topic0: String @index
  topic1: String @index
  topic2: String @index
  topic3: String @index
  block: Block!
  transaction: Transaction!
  logIndex: Int!
  transactionIndex: Int!
  removed: Boolean!
  decodedEvent: DecodedEvent
}

type DecodedEvent @entity {
  id: ID!
  eventSignature: String!
  eventName: String! @index
  args: JSON!
  address: Account!
  block: Block!
  transaction: Transaction!
  log: Log! @unique
  timestamp: DateTime! @index
}

type Trace @entity {
  id: ID!
  type: TraceType!
  from: Account!
  to: Account
  value: BigInt
  gas: BigInt
  gasUsed: BigInt
  input: String
  output: String
  error: String
  transaction: Transaction!
  traceAddress: [Int!]!
}

enum TraceType {
  CALL
  DELEGATECALL
  STATICCALL
  CREATE
  CREATE2
  SELFDESTRUCT
}

enum EventCategory {
  TOKEN
  NFT
  DEFI
  GAME
  GOVERNANCE
  UNKNOWN
}

type TokenTransfer @entity {
  id: ID!
  logIndex: Int!
  tokenStandard: TokenStandard! @index
  from: Account!
  to: Account!
  operator: Account
  token: Contract
  value: BigInt
  tokenId: String
  block: Block!
  transaction: Transaction!
  timestamp: DateTime! @index
}

enum TokenStandard {
  ERC20
  ERC721
  ERC1155
}

type TokenBalance @entity {
  id: ID!
  account: Account!
  token: Contract!
  balance: BigInt!
  transferCount: Int!
  lastUpdated: DateTime! @index
}

# ============ IPFS & Cross-Service Integration ============

type IPFSFile @entity {
  id: ID! # CID (bytes32 as string)
  cid: String! @index
  owner: Bytes! @index
  sizeBytes: BigInt!
  paidAmount: BigInt!
  paymentToken: Bytes!
  createdAt: DateTime! @index
  expiresAt: DateTime! @index
  isPinned: Boolean!
  
  # Categorization
  category: FileCategory! @index
  relatedContract: Bytes @index
  relatedEntityId: String @index
  
  # Metadata
  filename: String
  mimeType: String
  
  # Relations
  moderationReport: ModerationReport
  teeAttestation: TEEAttestation
  nftMetadata: NFTMetadata
  agentProfile: AgentProfile
  contestResult: ContestResult
}

enum FileCategory {
  MODERATION_EVIDENCE
  TEE_ATTESTATION
  GAME_ASSET
  NFT_METADATA
  AGENT_PROFILE
  CONTEST_RESULT
  ORACLE_DATA
  USER_CONTENT
}

type ModerationReport @entity {
  id: ID!
  reportId: BigInt!
  targetAgentId: BigInt!
  reporter: Bytes!
  reportType: ReportType!
  severity: ReportSeverity!
  evidenceIPFS: IPFSFile # Link to IPFS file
  details: String!
  status: ReportStatus!
  createdAt: DateTime!
}

enum ReportType {
  NETWORK_BAN
  APP_BAN
  LABEL_HACKER
  LABEL_SCAMMER
}

enum ReportSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ReportStatus {
  PENDING
  RESOLVED_YES
  RESOLVED_NO
  EXECUTED
}

type TEEAttestation @entity {
  id: ID!
  sessionId: Bytes!
  attestationIPFS: IPFSFile # TEE quote stored on IPFS
  contentHash: Bytes! # For verification
  gameType: GameType!
  timestamp: DateTime!
  verified: Boolean!
}

enum GameType {
  CALIGULAND
  EHORSE
  HYPERSCAPE
  GENERIC
}

type AgentProfile @entity {
  id: ID!
  agentId: BigInt!
  owner: Bytes!
  profileIPFS: IPFSFile # Profile JSON on IPFS
  stakeTier: Int!
  registered: DateTime!
  isBanned: Boolean!
}

type NFTMetadata @entity {
  id: ID!
  tokenId: BigInt!
  contract: Bytes!
  metadataIPFS: IPFSFile # Metadata JSON on IPFS
  owner: Bytes!
  mintedAt: DateTime!
}

type ContestResult @entity {
  id: ID!
  contestId: Bytes!
  resultsIPFS: IPFSFile # Full rankings on IPFS
  winner: Int!
  finalized: DateTime!
}

type StorageStats @entity {
  id: ID! # Date string
  date: DateTime!
  totalFiles: BigInt!
  totalSizeBytes: BigInt!
  totalRevenue: BigInt!
  activeUsers: BigInt!
  
  # By category
  evidenceFiles: BigInt!
  attestationFiles: BigInt!
  assetFiles: BigInt!
  metadataFiles: BigInt!
}

# ============ Game Feed & Player Events ============

type GameFeedPost @entity {
  id: ID!
  sessionId: String! @index
  postId: String! @index
  author: String! @index
  content: String!
  gameDay: Int!
  timestamp: DateTime! @index
  isSystemMessage: Boolean!
  blockNumber: BigInt!
  transactionHash: String!
}

type GameMarketUpdate @entity {
  id: ID!
  sessionId: String! @index
  yesOdds: Int!
  noOdds: Int!
  totalVolume: BigInt!
  gameDay: Int!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type GamePhaseChange @entity {
  id: ID!
  sessionId: String! @index
  phase: String!
  day: Int!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerSkillEvent @entity {
  id: ID!
  player: String! @index
  skillName: String!
  newLevel: Int!
  totalXp: BigInt!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerDeathEvent @entity {
  id: ID!
  player: String! @index
  killer: String @index
  location: String!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerKillEvent @entity {
  id: ID!
  killer: String! @index
  victim: String! @index
  method: String!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerAchievement @entity {
  id: ID!
  player: String! @index
  achievementId: String!
  achievementType: String!
  value: BigInt!
  timestamp: DateTime! @index
  blockNumber: BigInt!
  transactionHash: String!
}

type PlayerStats @entity {
  id: ID! # player address
  player: String! @unique @index
  totalSkillEvents: Int!
  totalDeaths: Int!
  totalKills: Int!
  totalAchievements: Int!
  highestSkillLevel: Int!
  highestSkillName: String
  lastActive: DateTime! @index
}

# ============ Node Staking & Governance ============

type NodeStake @entity {
  id: ID! # nodeId
  nodeId: String! @unique @index
  operator: String! @index
  stakedToken: String!
  stakedAmount: BigInt!
  stakedValueUSD: BigInt!
  rewardToken: String!
  totalRewardsClaimed: BigInt!
  lastClaimTime: BigInt!
  rpcUrl: String!
  geographicRegion: Int!
  registrationTime: BigInt!
  isActive: Boolean!
  isSlashed: Boolean!
  currentUptimeScore: BigInt
  currentRequestsServed: BigInt
  currentAvgResponseTime: BigInt
  performanceUpdates: [PerformanceUpdate!]! @derivedFrom(field: "node")
  rewardClaims: [RewardClaim!]! @derivedFrom(field: "node")
}

type PerformanceUpdate @entity {
  id: ID!
  node: NodeStake!
  uptimeScore: BigInt!
  requestsServed: BigInt!
  avgResponseTime: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type RewardClaim @entity {
  id: ID!
  node: NodeStake!
  operator: String!
  rewardToken: String!
  rewardAmount: BigInt!
  paymasterFeesETH: BigInt!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

type OperatorStats @entity {
  id: ID! # operator address
  operator: String! @unique @index
  totalNodes: Int!
  totalStaked: BigInt!
  totalRewardsClaimed: BigInt!
  averageUptime: BigInt!
  lastActive: DateTime! @index
}

type TokenDistribution @entity {
  id: ID!
  token: String! @index
  totalStaked: BigInt!
  totalNodes: Int!
  averageStake: BigInt!
  lastUpdated: DateTime! @index
}

type NetworkSnapshot @entity {
  id: ID! # timestamp
  timestamp: DateTime! @index
  totalNodes: Int!
  activeNodes: Int!
  totalStaked: BigInt!
  totalStakedUSD: BigInt!
  averageUptime: BigInt!
}

type GovernanceProposal @entity {
  id: ID! # proposalId
  proposalId: Bytes! @unique @index
  parameter: String!
  currentValue: BigInt!
  proposedValue: BigInt!
  changeMarketId: Bytes!
  statusQuoMarketId: Bytes!
  createdAt: BigInt!
  votingEnds: BigInt!
  executeAfter: BigInt!
  executed: Boolean!
  vetoed: Boolean!
  proposer: String!
  events: [GovernanceEvent!]! @derivedFrom(field: "proposal")
}

type GovernanceEvent @entity {
  id: ID!
  proposal: GovernanceProposal!
  eventType: String!
  actor: String
  reason: String
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: String!
}

# ============ ERC-8004 Registry ============

type RegisteredAgent @entity {
  id: ID!
  agentId: BigInt! @unique @index
  owner: Account!
  tokenURI: String
  name: String!
  description: String
  tags: [String!]!
  stakeToken: String!
  stakeAmount: BigInt!
  stakeWithdrawn: Boolean!
  registeredAt: DateTime! @index
  depositedAt: BigInt!
  withdrawnAt: BigInt
  active: Boolean!
  a2aEndpoint: String
  metadataUpdates: [AgentMetadata!]! @derivedFrom(field: "agent")
  stakes: [RegistryStake!]! @derivedFrom(field: "agent")
  tagUpdates: [TagUpdate!]! @derivedFrom(field: "agent")
}

type RegistryStake @entity {
  id: ID!
  agent: RegisteredAgent!
  token: String!
  amount: BigInt!
  depositedAt: BigInt!
  txHash: String!
  blockNumber: Int!
}

type AgentMetadata @entity {
  id: ID!
  agent: RegisteredAgent!
  key: String!
  value: String!
  updatedAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

type TagUpdate @entity {
  id: ID!
  agent: RegisteredAgent!
  oldTags: [String!]!
  newTags: [String!]!
  updatedAt: DateTime! @index
  txHash: String!
  blockNumber: Int!
}

# ============ Prediction Market Entities ============

type PredictionMarket @entity {
  id: ID! # sessionId (bytes32)
  sessionId: String! @unique @index
  question: String!
  liquidityB: BigInt!
  yesShares: BigInt!
  noShares: BigInt!
  totalVolume: BigInt!
  createdAt: DateTime! @index
  resolved: Boolean! @index
  outcome: Boolean
  
  # Relations
  trades: [MarketTrade!]! @derivedFrom(field: "market")
  positions: [MarketPosition!]! @derivedFrom(field: "market")
}

type MarketTrade @entity {
  id: ID! # txHash-logIndex
  market: PredictionMarket!
  trader: Account!
  outcome: Boolean!
  isBuy: Boolean!
  shares: BigInt!
  cost: BigInt!
  priceAfter: BigInt!
  timestamp: DateTime! @index
}

type MarketPosition @entity {
  id: ID! # marketId-traderId
  market: PredictionMarket!
  trader: Account!
  yesShares: BigInt!
  noShares: BigInt!
  totalSpent: BigInt!
  totalReceived: BigInt!
  hasClaimed: Boolean!
  lastUpdated: DateTime! @index
}

type OracleGame @entity {
  id: ID! # sessionId (bytes32)
  sessionId: String! @unique @index
  question: String!
  commitment: String!
  committedAt: DateTime! @index
  finalized: Boolean! @index
  revealedAt: DateTime
  outcome: Boolean
  winners: [String!]!
  totalPayout: BigInt!
  market: PredictionMarket
}

type MarketStats @entity {
  id: ID! # Date string
  date: DateTime! @index
  totalMarkets: BigInt!
  activeMarkets: BigInt!
  resolvedMarkets: BigInt!
  totalVolume: BigInt!
  totalTrades: BigInt!
  uniqueTraders: BigInt!
}

# ============ EIL (Ethereum Interop Layer) Entities ============

type XLP @entity {
  id: ID! # XLP address
  address: String! @unique @index
  stakedAmount: BigInt!
  unbondingAmount: BigInt!
  unbondingStartTime: BigInt
  slashedAmount: BigInt!
  isActive: Boolean! @index
  registeredAt: DateTime! @index
  supportedChains: [Int!]!
  
  # Performance metrics
  totalVouchersIssued: Int!
  totalVouchersFulfilled: Int!
  totalVouchersFailed: Int!
  totalFeesEarned: BigInt!
  averageResponseTimeMs: Int!
  reputation: Int! @index # 0-100
  
  # Liquidity
  liquidityDeposits: [XLPLiquidityDeposit!]! @derivedFrom(field: "xlp")
  vouchersIssued: [CrossChainVoucher!]! @derivedFrom(field: "xlp")
}

type XLPLiquidityDeposit @entity {
  id: ID! # xlp-token-chainId
  xlp: XLP!
  token: String! @index
  chainId: Int! @index
  amount: BigInt!
  ethAmount: BigInt!
  lastUpdated: DateTime! @index
}

type CrossChainVoucherRequest @entity {
  id: ID! # requestId (bytes32)
  requestId: String! @unique @index
  requester: Account!
  sourceChain: Int! @index
  destinationChain: Int! @index
  sourceToken: String! @index
  destinationToken: String!
  amount: BigInt!
  maxFee: BigInt!
  currentFee: BigInt!
  feeIncrement: BigInt!
  recipient: String!
  gasOnDestination: BigInt!
  deadline: BigInt!
  createdAt: DateTime! @index
  createdBlock: BigInt!
  
  status: VoucherRequestStatus! @index
  claimed: Boolean!
  expired: Boolean!
  refunded: Boolean!
  
  voucher: CrossChainVoucher
}

enum VoucherRequestStatus {
  PENDING
  CLAIMED
  FULFILLED
  EXPIRED
  REFUNDED
}

type CrossChainVoucher @entity {
  id: ID! # voucherId (bytes32)
  voucherId: String! @unique @index
  request: CrossChainVoucherRequest!
  xlp: XLP!
  
  sourceChainId: Int!
  destinationChainId: Int!
  sourceToken: String!
  destinationToken: String!
  amount: BigInt!
  fee: BigInt!
  gasProvided: BigInt!
  
  issuedAt: DateTime! @index
  issuedBlock: BigInt!
  expiresBlock: BigInt!
  
  status: VoucherStatus! @index
  fulfilled: Boolean!
  slashed: Boolean!
  
  # Transaction hashes
  sourceClaimTx: String
  destinationFulfillTx: String
  fulfillmentTime: DateTime
}

enum VoucherStatus {
  ISSUED
  FULFILLED
  EXPIRED
  SLASHED
}

type EILTransfer @entity {
  id: ID! # unique transfer ID
  user: Account!
  
  sourceChain: Int! @index
  destinationChain: Int! @index
  sourceToken: String!
  destinationToken: String!
  amount: BigInt!
  fee: BigInt!
  
  xlp: XLP
  request: CrossChainVoucherRequest
  voucher: CrossChainVoucher
  
  status: TransferStatus! @index
  initiatedAt: DateTime! @index
  completedAt: DateTime
  
  sourceTxHash: String!
  destinationTxHash: String
}

enum TransferStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  REFUNDED
}

type XLPSlashEvent @entity {
  id: ID!
  xlp: XLP!
  voucherId: String! @index
  chainId: Int!
  amount: BigInt!
  victim: String!
  timestamp: DateTime! @index
  disputed: Boolean!
  txHash: String!
}

type EILStats @entity {
  id: ID! # "global" or date string for daily stats
  date: DateTime @index
  
  totalVolumeUsd: BigInt!
  totalTransactions: BigInt!
  totalXLPs: Int!
  activeXLPs: Int!
  totalStakedEth: BigInt!
  
  averageFeePercent: Int! # basis points
  averageTimeSeconds: Int!
  successRate: Int! # 0-100
  
  last24hVolume: BigInt!
  last24hTransactions: BigInt!
}

type EILChainStats @entity {
  id: ID! # chainId
  chainId: Int! @unique @index
  chainName: String!
  
  paymasterAddress: String!
  totalVolume: BigInt!
  totalTransfers: BigInt!
  activeXLPs: Int!
  totalLiquidity: BigInt!
  
  lastUpdated: DateTime! @index
}
